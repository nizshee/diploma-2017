1.
Существует много методов позволяющих убедиться что написанная программа ведет себя
в соответсвии с некоторой спецификацией: явной или неявной.
Наверное, самым популярным методов являются системы типов.
Типы были еще в самых ранних языках программирования и более-менее хорошо знакомы всем.
Мы же будем будем рассматривать систему типов языка скала.
..Эта система типов является статической, т.е. тип выражения известен уже в момент компиляции.
..Также он является строгим, т.е. не выполняется неявных преобразований над типами.
Но что наиболее интересно для нас, компилятор скалы умеет сам выводить некоторые недостающие типы.
Это позиционируется как - указывайте в классах типы переменных и сигнатуры методов,
а все остальное, связанное с типами выведет за нас компилятор.

2.
Именно процесс вывода типов за нас компилятором мы и будем рассматривать.
Конкретно, нас будут интересовать три его составлящие.
В первую очередь это процесс сводимости типов.
У нас есть место для выражения с ожидаемый тип A.
Правда ли что мы можем подставить туда выражение с типом B.
Дальше идет сам вывод типов.
Кстати, сводимость типов является составной частью вывода типов.
Когда мы выводим тип, то заменяем в нем все абстрактные переменные на какие-то абстрактные типы.
Во время сведения получаем ограничения на эти абстрактные переменные, а потом пытаемся решить эти ограничения.
Заодно сюда попал процесс выбора перегрузки, по необъяснимой на данный момент причине.

3.
Эти процессы в спецификации описываются как набор формальных правил.
а.
Это по сути дерево доказательства.
Если есть доказательство, то можно проверить его корректность.
Однкао автоматически строить доказательства не так просто.

б.
В спецификации описаны три случая использования нахождения неуказанных типовых параметров.
Это может быть либо выбор в выражении какого-то имени.
Либо выражение само по себе, либо применения аргументов к выражению.
Последний случай наиболее интересен, т.к. именно в нем появляется абстрагирование по типу.

в.
Так же важен, т.к. в скале, как и во многих других языках разрешена перегрузка функций,
а значит должен быть сопособ найти функцию наиболее специфичную для каждой ситуации.

Описано в спецификации скалы на декларативном уровне.
Не написано конкретной реализации.
Полной спецификацией алгоритма является код компилятора.

Сообщение в консоль вида [ожидалось, вывелось]

4.
Что-то про существуюзее решение.
Это дает размышление что если мы хотим визуализировать какой-то процесс,
то делать это нужно в рамках какой-то существующей системы.
Заметим, что до этого речь шла о компиляторе скалы, но все то же самое можно применить
и к ide скалы.
Действительно, не зная информации о типах, среда не сможет корректно подсвечивать семантические ошибки.
Как пример такой среды можно взять scala plugin для inteliji idea.
Заодно еще один минус.

5.
Теперь можно поставить конкретную цель и определить задачи.
`Сказать то что на слайде другими словами.`

6.
Рассмотрим упрощенно основные системы связанные с разбором типов в плагине.
Допустим что у нас есть применение функции к каким то аргументом.
Мы хотим понять что это значит, какой тип возвращаемого значения.
Точкой входа является метод resolve класса ReferenceExpressionResolver.
Он дает задачу по нахождению смысла классу MethodResolveProcessor.
Допустим у нас есть кандидат.
Тогда мы хотим понять насколько аргументы применимы к нему.
Для этого мы вызываем функцию compatible, которая использует conformsInner для
проверки того что тип аргумента сводится к ожидаемому типу.
После всего этого у нас появляются ограничения на абстрактные типы,
которые мы решаем с помощью ScUndefinedSubstitutor.
Так как кандидатов не обязательно один, то нужно найти среди них натюолее специфичного,
чем и занимается MostSpecificUtil.

Вместе с модулем с калссом ScUndefinedSubstitor, отвечающем за вывод типов,
мы получаем некую вариацию алгоритма

Соответсвенно инструментированию подверглтсь области связанные с это схемой.

7.
Теперь поговорим об уменьшении влияния инструментации на процесс выполнения.
Лучшая инструментация - это та которая нет.
Соответственно появилась идея вырезать написанную интсрументацию с помомщью макросов.
Идея в том чтобы передавать объект инстументирования как агрумент функции или конструктора.
После этого автоматически сгенерировать две функции или класса - один с инструментации, другой без.
В неиснтрументированной версии исчезают все упоминания об инструментации.
Все вызовы связанные с объетом инструментации заменяются на вызов инструментированных вызовов.
На использование объекта инструментации накладываются некоторые ограничения.

8.
Несмотря ни на что, скала не самый простой язык не только для использования, но и для анализа.

С другой стороны скала плагин - это большой промышленый проект, который долго развивался независимо от scala.
Не все понятия введенные в спецификации одназначно отображаются на то что есть в плагине.
..комментирование кода
Отдельной проблемой было понять как должен выглядить внятный пользовательский интерфейс.
Но и работа с макросами та еще тема.
..момент с применением конструктора супер

...
2ый слайд
перечмсление большая буква
выводом

4
спецификация scala
убрать в специфмкации
случаи локального вывода типа

5
... использует
имплиситы в скала плагине как существующее решение (!!!)

6.
Инструментировать

8.
Сложность скалы.
Пользовательский интерефейс.

14.
Ссылка на гитхаб.

MethodInvoaction

отладчик вывода типов языка програмимирования scala в intellij idea


...
абстрактные типы
вывод для функций
