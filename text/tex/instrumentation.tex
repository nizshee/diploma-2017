\section{Особенности реализации}
\label{sec:features}
В этом разделе мы будем говорить о получении данных из того или иного процесса
внутри Scala Plugin.
Здесь и далее под процессом понимается последовательность выборов, принимаемых функциями и
классами внутри Scala Plugin, направленных на решение какой-то задачи, скорее
всего, связанной с типами.
Для начала нужно определиться, как именно будут получены эти данные.
Сделаем несколько наблюдений:

\begin{itemize}
  \item Чтобы не заниматься обратным анализом и не перереализовывать функциональность плагина,
  отвечающую за работу с типами, разумным выглядит переиспользовать уже существующую кодовую базу.
  \item Данные полученные о процессах нужно будет визуализировать.
  Поэтому хотелось бы их получать как полноценные объекты scala, а не как, скажем,
  набор снимков состояния стэка которые нуждаются в последующей обработке.
  Для этого формирование этих объектов должно быть отражено в коде рассматриваемых процессов.
  \item Scala Plugin написан на языке программирования scala.
  И хоть scala позициоирует себя как язык с функциональной направленностью,
  однако большая часть кода в плагине, необходимая для анализа процессов связанных с типами,
  написана в императивном стиле.
  То есть используются изменяемые состояния объектов, функции не всегда являются чистыми,
  а поток управления часто прерывается ключевым словом return.
  Поэтому во время получения данных было бы удобно пользоваться изменяемым состоянием.
\end{itemize}

В таких условиях разумной выглядит идея инструментировать фрагменты Scala Plugin,
отвечающие за интересующие нас процессы.
А именно, помещать в контекст выполнения процесса специальные объекты,
которык будут хранить данные о текущем состоянии процесса,
работа с которыми будет описана прямо в коде плагина.
Подробно это будет рассмотрено в разделе~\ref{sec:instrumentation}.
% , и которые далее мы будем называть объектами инструментации

% todo рабочее
Однако, не стоит забывать, что Scala Plugin - это рабочее приложение
с большим количеством пользователь.
А код отвечающий за работу с типами, как минимум за сведение типов,
выполняется в плагине на каждом шагу.
Поэтому внесение дополнительных действий в этот код окажет пагубное воздействие
на производительность всего плагина.
Чтобы уменьшить воздействие инструментирования на производительность остального кода,
в данной работе принято решение использовать макросы.
Обзор возможностей макросов в scala приведен в разделе~\ref{sec:macroScala}.
Их применение к инструментированию на примере функций будет расммотрено в
разделе~\ref{sec:macroFunction}, а распространение на классы
в разделе~\ref{sec:macroClass}.

% В конце будет раздел~\ref{sec:data}, посвященный формату хранения данных.

\subsection{Инструментирование}
\label{sec:instrumentation}

Здесь мы составим набор правил для использования инструментации так,
будто макросов нет.
Это позволит нам запускать Scala Plugin даже без них.
А в последующих разделах мы увидим что построенная система хорошо подходит
для анализа на уровне исходного кода.

Принцип, которым мы будем руководствоваться - инструментация должна быть опциональной.
Это означает что для запуска инструментированной версии кода нужно приложить
какие-то усилия, внешний код не обязан знать что возможно инструментирование.
Если ее не включить, влияние инструментирования на классы и функции будет
максимально снижено, поведение будет таким, каким было до инструментирования.

Попробуем представить как должно выглядеть инструментирование для, например,
функции \textbf{f}.
Нам необходимо передать объект инструментации внутрь функции и дать знать,
нужно ли его использовать.
Это можно сделать или с помощью двух дополнительных параметров функции:
объекта и флага, или с помощью одного дополнительного параметра объекта,
который может принимать значение \textbf{null}.
Но в функциональном программировании есть более выразительное средство -
монада \textbf{Option}.
Значение по умолчанию \textbf{None} позволит не изменять уже существующие
вызовы функции \textbf{f}, как в примере кода~\ref{lst:opt}.

\begin{lstlisting}[caption={Явная передача объекта инструментирования внутрь функции},label=lst:opt]
def f(..., instrumentation: Option[Instrumentation] = None)
\end{lstlisting}

Монаду \textbf{Option} с объектом через который будет производиться
инструментирование мы будем называть объектом инструментирования.
Когда нужно будет солаться на сам объект, будет употребляться слово
непостредственный объект инструментирования.

\textbf{Option} и его функции высшего порядка такие как \textbf{map} и
\textbf{foreach} автоматически дают нам контекст, в котором мы можем выполнять
любые необходимые действия,
в области видимости которого есть непосредственный объект инструментирования,
и которые игнорируются если \textbf{Option} оказался пуст.
Это показано в примере кода~\ref{lst:ctx}.

\begin{samepage}
\begin{lstlisting}[caption={Действия внутри контекста инструментирования},label=lst:ctx]
instrumentation.foreach { i =>
  val a = computeA
  i.addInformation(a)
}
\end{lstlisting}
\end{samepage}

Далее мы будем говорить про \textbf{Option} как о контексте инструментирования.
Соответвенно, объект инструментирования создает контекст инструментирования,
в котором с помощью функций высшего порядка мы можем выполнять какие-то действия,
и который может оказаться пуст.

Теперь поймем как хранить данные которые изменяются со временем.
Понятно что мы можем их хранить внутри объекта инструментирования, и у нас нет другого
выхода если эти данные обновляются внутри вложенных вызовов функций.
Однако один и тот же объект инструментирования может появляться в множестве разных
контекстов и включение в него логики обработки промежуточных данных для
всех этих случаев может показаться избыточным.
Решением будет вынесение этих данных в изменяемую переменную.
Однако, мы хотим чтобы действия над этой переменной зависели от наличия объекта
инструментации.
Для этого можно явно связать переменную с объектом инструментации,
в примере кода~\ref{lst:mut} показано как это сделать используя функцию \textbf{map}.

\begin{samepage}
\begin{lstlisting}[caption={Привязка к контексту инструментирования},label=lst:mut]
var intermediate = instrumentation.map(_ => Seq.empty[R])
for (i <- 0 to n) {
  val r = findResultFor(i)
  intermediate = intermediate.map(_ :+ r)
  doSomeStuff(r)
}
\end{lstlisting}
\end{samepage}

В нем мы явно связали переменную \textbf{intermediate} с контекстом
инструментирования объекта \textbf{instrumentation}.
Тем самым мы породили дополнительный контекст инструментации.
Аналогичным приемом можно воспользоваться если мы захотим создать дополнительный
объект инструментирования.
Это может понадобиться, например, для вложенных вызовов, как в примере
кода~\ref{lst:inner}.

\begin{lstlisting}[caption={Создание нового объекта инструментирования},label=lst:inner]
val inner = instrumentation.map(_.inner)
g(..., instrumentation = inner)
instrumentation.foreach(_.add(inner.get.data))
\end{lstlisting}

Таким образом новые контексты инструментирования можно создавать явно,
используя уже существующие через функцию \textbf{map}.

% \textit{При возникновении новых сущностей связанных с
% инструментированием, мы явно устанавливаем связь с уже существующими объектами.}

Разумным требованием кажется избегать влияния влияние интрументирования на
логику функции.
Но так ли это?
Рассмотрим в качестве примера проверку сводимости двух параметризованных типов.
Для сводимости одного типа к другому необходимо чтобы количества типовых аргументов
совпадали и для каждой пары соответствущих типовых аргументов выполнялось
определенное соотношение.
При проверке этих соотношений достаточно дойти до первого ложного чтобы понять что
сводимость нет, что Scala Plugin и делает.
Однако в целях отладки было бы более информативно проверить все соотношения чтобы дать
пользователю более полную картину.

Таким образом возможность изменять поведение изначальной функции нам нужна.
Однако, есть версия что достаточно уметь делать две вещи:
изменять выбранную вертку исполнения в условных конструкциях при включенном
инструментировании, а также избегать прерывания потока исполнения ключевым
словом \textbf{return}.

Основной идеей будет то что квантор всеобщности над пустым множеством всегда
верен, а квантор сущестования нет.
Таким образом мы можем использовать логику основанную на существовании контекста
инструментирования в связке с логическим или, а также условия для любого объекта
в связке с логиеским и.
Также заметим что любую конструкцию, тип которой \textbf{Unit}, такую как
\textbf{return}, мы можем записать через \textbf{if (true)}.

Пример кода~\ref{lst:cond} иллюстрирует это.
В нем мы мы сначала игнорируем кэшированное значения с помощью проверки,
возвращающей \textbf{false} на непустом множестве.
Далее функции \textbf{computeA} и \textbf{computeB} из которых мы извлекаем данные.
Чтобы не прерываться после неудавшейся проверки \textbf{conditionA}, мы добавляем
условный оператор.
Если \textbf{instrumentation} пуст, то \textbf{forall} вернет \textbf{true} и
поток исполнения прервется.
В обратном случае выполнится \textbf{interrupt}, который поднимет флаг остановки, а
\textbf{forall} вернет \textbf{false} и поток исполнения продолжится.
В конце мы с помощью \textbf{exists} проверяем был ли поднят флаг прерывания в
процессе работы, и если бы то возвращаем соответствующее значение.

\begin{lstlisting}[caption={Влияние на первоначальную логику},label=lst:cond]
val cached = cache.get(key)
if (cached != null && instrumentation.isEmpty) return cached

val conditionA = computeA(instrumentation = instrumentation)
if (conditionA)
  if (instrumentation.forall(!_.interrupt())) return false
val conditionB = computeB(instrumentation = instrumentation)
if (instrumentation.exits(_.interrupted())) return false
return conditionB
\end{lstlisting}

До этого момента мы говорили только о функциях.
Достаточно ли нам уметь работать только с ними?
Вообще говоря достаточно, но работать только с функциями неудобно.

Встречаются классы которые выступают как контейнеры функций.
Примерами могут послужить \textbf{MostSpecificUtil} и
\textbf{MethodResolveProcessor}.
Вместо того чтобы добавлять по параметру с объектом инструментации в каждый
метод, намного проще добавить один парметр в их конструкторы.
В будущем это усложнит макрос. % задачу написания макроса

\subsection{Макросы в scala}
\label{sec:macroScala}

Прежде чем говорить о макросах в scala, следует понять что имеется в виду под
словом макрос.
Изначально, макрокоманда или макрос -- это символьное имя,
заменяемое при обработке исходного кода препроцессором на некоторый текст.
Наиболее известный пример макросов можно встретить в препроцессорах языков
программирования C и C++.

Подобные макросы работают по следующему механизму.
В начале пользователь описывает с помощью специального синтаксиса функцию,
которая примнимает в качестве параметров строковые константы, а возвращает текст,
в который могут быть подставлены значения этих параметров.
Перед компиляцией текста препроцессор проходит по тексту исходного кода и заменяет
вызовы этих функций на соответсвующие значения.
Как простые строки, без каких-либо проверок.
И только после этого, полученный текст отдается компилятору.

Использование макросов в scala контрастирует с вышеописанным подходом.
Главным отличием является то, что макросы в scala работают не со строками,
а с абстрактными синтаксическими деревьями, представляющими исходный код
программы.
Scala макросы пишутся на полноценном scala и являются функциями, принимающими
АСД фрагментов исходного кода и возвращающие АСД фрагментов которые нужно
сгенерировать.
То есть для того чтобы применить макрос к коду, компилятору требуется построить
АСД этого кода. Тем самым макросы не изменяют изначальный синтаксис, а лишь
преобразуют код.

\subsubsection{Macro Paradise}

Обычно такие макросы используют чтобы автоматически генерировать что-то для
класса, например сериализаторы.
И эти возможности предоставляет сам компилятор.
Однако существует плагин к компилятору Macro Paradise, который позволяет не
просто создавать новый код, но и заменять существующий.
Именно эту возможность мы и будем использовать для того чтобы снизитить влияние
кода инструментирования на процесс исполнения.

Для того чтобы использовать Macro Paradise нужно создать специальную аннотацию,
которой должны быть помечены функции и классы, код которых мы хотим изменить.
В класс этой аннотации должен быть добавлен код функции-генератора АСД.

Теперь поймем, чего мы хотим добиться используя кодогенерацию.
С одной стороны мы бы хотели полностью избавиться от кода связанного с инструментацией,
чтобы он никак не влиял на производительность плагина.
С другой стороны, эта инструментация добавлялась не просто так.
Выходом будет сгенерировать две копии каждой функции: одну с инструментацией,
другую без.
То же самое для классов.

\subsection{Макросы для функций}
\label{sec:macroFunction}

Сформулируем правила для инструментирования которое обсуждалось в
разделе~\ref{sec:instrumentation}:
\begin{enumerate}
  \item
  \label{itm:ins-constructor}
  Объект инструментирования передается явно как параметр функции или
  конструктора классов в монаде \textbf{Option} со значением по умолчанию
  \textbf{None}.
  \item
  \label{itm:ins-context}
  Действия связанные с инструментированием не должны покидать контекст
  инструментирования.
  \item
  \label{itm:ins-creating}
  Создание нового контекста инструментирования происходит явно от другого,
  уже существующего, контекста инструментирования.
  Для этого подходит функция функция \textbf{map}.
  \item
  \label{itm:ins-logic}
  Для того чтобы влиять на первоначальную логику добавляются
  инвариантные для пустого контекста инструментирования условия.
\end{enumerate}

В этом разделе наша задача - по коду инструментированной функции \textbf{f}
сгенерировать пару новых функций \textbf{f} и \textbf{f\$I}.
Здесь \textbf{f} - это замена старой функции в которой будет удалено
все инструментирование.
\textbf{f\$I} - функция в которой оставлена инструментация.

\subsubsection{Поиск инструментирования}

\begin{algorithm}
  \caption{Обновление информации о контекстах инструментирования}\label{alg:names}
  \begin{algorithmic}[1]
    \Function{UpdateInstrumentationNames}{$codeBlock, previousNames$}
    \State $names \gets previousNames$
    \For {$expr \gets$ выражения внутри $codeBlock$}
    \If {$expr$ объявление символа $n$ с использованием $names$}
    \State $names \gets names$ добавить $n$
    \ElsIf {$expr$ объявление символа $n$}
    \State $names \gets names$ убрать $n$
    \EndIf
    \EndFor
    \State \Return names
    \EndFunction
  \end{algorithmic}
\end{algorithm}

Мы рассмотрим процесс генерации на очень концептуальном уровне.
И прежде всего нам потребуется вспомогательная функция
\textbf{GetInstrumentationNames} из алгоритма~\ref{alg:names}.

Эта функция нужна для обновления информации об именах связанных с
инструментированием.
Входными данными является: блок кода образующий новую область видимости и
имена из вышележащей области видимости.
Требуется найти в блоке кода имена с новыми контекстами инструментирования,
а также убрать имена затененные.
Это не сложно сделать, так как по пункту~\ref{itm:ins-creating} связь между
новыми и старыми контекстами отслеживается в коде явно.
Новые имена получаются из старых при помощи функции \textbf{map},
остальное затенение.

\subsubsection{Генерация неинструментированной функции}

\begin{algorithm}
\caption{Генерация неинструментированной функции}\label{alg:nonins}
\begin{algorithmic}[1]
\Function{GetNonInstrumentedFunction}{$func, parameterName$}
  \State удалить $parameterName$ из сигнатуры функции $func$
  \State $codeBlock \gets$ получить тело $func$
  \State $HandleNonInstrumentedBlock(codeBlock, parameterName)$
\EndFunction

\Function{HandleNonInstrumentedBlock}{$codeBlock, previousNames$}
  \State $names \gets UpdateInstrumentationNames(codeBlock, previousNames)$
  \For {$expr \gets$ выражения внутри $codeBlock$}
    \If {$expr$ это условние в котором есть только элемент из $names$}
      \State заменить все условное выражение на одну из ветвей
    \ElsIf {$expr$ это условие содержащее элемент из $names$}
      \State упростить условие, исключив из него элементы из $names$
    \ElsIf {$expr$ это вызов с использованием элемента из $names$}
      \State удалить аргументы связанные с $names$ из вызова
    \ElsIf {$expr$ основан на элементе из $names$}
      \State удалить $expr$
    \ElsIf {$expr$ это новый блок кода}
      \State $HandleInstrumentedBlock(expr, names)$
    \ElsIf {$expr$ содержит элемент из $names$}
      \State \Return ошибка
    \EndIf
  \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

Теперь перейдем к рассмотрению генерации неинструментированной версии функции.

Функция \textbf{GetNonInstrumentedFunction} из алгоритма~\ref{alg:nonins}
выполняет искомую задачу.

По пункту~\ref{itm:ins-constructor} среди параметров этой функции должен быть
объект инструментации.
Допустим что нам известно его имя.
В первую очередь удаляем его.

Удалить действия связанные с инструментацией тоже не сложно.
Все они, по пункту~\ref{itm:ins-context}, находятся в соответствущих контекстах
связанных с именами объектов,а множество имен объектов у нас есть.
Заодно из кода вырезаются передачи этих объектов в вызовы функций.
Именно для этого требовалась явная передача аргументов в
пункте~\ref{itm:ins-constructor}.
Несмотря на то что можно было воспользоваться механизмом implicit,
нам бы потребовалась помощь компилятора чтобы находить передачу контекста
инструментирования.

Осталось наше влияние на первоначальную логику.
Но оно из пункта~\ref{itm:ins-logic} ограничивается использованием объектов
инструментиорвания в условиях.
Чтобы вернуть все как было достаточно упростить все логические выражения,
подразумевая что используемые в них контексты инструментирования пусты.
А также удалить условные конструкции, если они зависят только от объектов
инструментирования.

\subsubsection{Генерация инструментированной функции}

\begin{algorithm}
\caption{Генерация инструментированной функции}\label{alg:ins}
\begin{algorithmic}[1]
\Function{GetInstrumentedFunction}{$func, parameterName$}
  \State добавить к названию функции $func$ суффикс $\$I$
  \State $codeBlock \gets$ получить тело $func$
  \State $HandleInstrumentedBlock(codeBlock, parameterName)$
\EndFunction

\Function{HandleInstrumentedBlock}{$codeBlock, previousNames$}
  \State $names \gets UpdateInstrumentationNames(codeBlock, previousNames)$
  \For {$expr \gets$ выражения внутри $codeBlock$}
    \If {$expr$ это вызов с использованием элемента из $names$}
      \State добавить к имени символа суффикс $\$I$
    \ElsIf {$expr$ это новый блок кода}
      \State $HandleNonInstrumentedBlock(expr, names)$
    \EndIf
  \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}


Логика генерации инструментированной функции намного проще.
Здесь нам достаточно изменить название самой функции и проследить чтобы все
вызовы, в которые были переданы контексты инструментирования, были
перенаправлены в инструментированный код.

\subsubsection{Анализ предложенного решения}

Предложенное решение вернет функцию \textbf{f} к изначальному виду, тем самым
решая поставленную задачу.
Избыточность создается только из-за увеличения количества функций
доступных для виртуальной машины java.

Также стоит заметить что применение аннотации к функции автоматически форсирует
нас использовать аннотации на всех вызванных внутри функциях, в которые мы передали
объекты инструментации.
Действительно, в инструментированной версии к этим функциям будет добавлен
суффикс \textbf{\$I} и код не скомпилируется если мы не позаботимся об их наличии.

\subsection{Макросы для классов}
\label{sec:macroClass}
Теперь перейдем к рассмотрению работы макроса на классе.
Нашей задча остается прежней - по классу \textbf{C} сгенерировать пару:
инструментированный класс и неинструментированный.

Прежде всего заметим, что все относящееся к обработке инструментирования внутри
функции также верно и для класса.
Здесь нас будут интересовать проблемы при создании классов, а также возможности
их преодаления.
До этого момента все было хорошо.
Это связано с тем что функция не несет в себе состояния.
Она не участвует ни в каких иерархиях и для нее понятие инкапсуляции абсолютно.

\subsubsection{Создание дополнительного класса}

Однако первая проблема с которой мы столкнемся будет не проблема наследования,
а сообщение Macro Paradise
"error: top-level class with companion can only expand into a block consisting
in eponymous companions".
Проблема заключается в следующем, Macro Paradise не добавляет новые имена в
верхний уровень видимости.
Единственное исключение - для класса можно сгенерировать его объект-компаньон.
В нашем же случае почти все классы вызывающие интерес лежат в верхнем уровне
видимости.

Что же, воспользуемся единственным исключением и вместо инструментированного
класса \textbf{C\$I} создадим инструментированный класс \textbf{\$I} который
будет лежать в объекте-компаньоне \textbf{C}.
Это решит проблему появления глобальных имен, и вызовы конструктора класса
\textbf{new C} в инструментированной версии будут перенаправляться
в \textbf{new C.\$I}.

\subsubsection{Наследование}

Следующей проблемой будет - кто являются родителями \textbf{\$I}.
Кажется разумным выбрать тех же родителей что и у \textbf{C}.
Это правда пока не появляется функция принимающая \textbf{C} и вызываемая
внутри инструментрованного кода.
В качестве примера можно привести класс \textbf{MethodResolveProcessor}
который передает себя в метод \textbf{candidates} объекта-компаньона
по ссылке \textbf{this}.
Можно попытаться сгенерировать две копии метода \textbf{candidates},
но в таком случае становится сложнее отслеживать распространение контекста
инструментирования.
То что было описано в разделе~\ref{sec:instrumentation} перестанет работать.
А за счет возможности импортировать имена из объектов (которой воспользовались
в плагине), без помощи компилятора даже нельзя понять, какие вызовы относятся
к тому что мы передали, а какие нет.

Остается наследование от \textbf{C}, чтобы номинальная система типов не могла
отличить от него \textbf{\$I}.

\subsubsection{Внутреннее состояние}

В начале поговрим о внутреннем состоянии класса.
Данные хранятся в переменных, изменяемых или неизменяемых.
А эти переменные могут быть или публичными, или приватными.
Часть из них объявлена в конструкторе.
Помимо этого у класса может быть инициализаци, которая может содержать побочные
эффекты.

Самое первое - нужно запретить инициализацию объекта.
С одной стороны из-за принципа инкапсуляции мы не можем проигнорировать
конструктор класса \textbf{C}.
С другой, если там должно было быть инструментирование, то нам нужно перезапустить
конструктор в классе \textbf{\$I}, но уже с ним.
Это может привести либо к несогласованности внутри класса, либо, если есть
побочные эффекты, к неожиданным внешним проявлениям.
Самое простое - запретить общую инициализацию объекта, оставив передачу параметров.
Причем, оказывается что в нашем случае это не очень большое ограничение.
Как говорилось в начале раздела~\ref{sec:features}, нас интересуют классы
являющиеся упаковками функций.
В них отсутсвует секция инициализации.

Теперь нужно разобраться с переменными класса.
Если нет инициализации, то публичные переменные класса \textbf{C} мы можем
просто переиспользовать в методах класса \textbf{\$I}.
Приватные же переменные класса \textbf{C} не покидают его область
видимости, поэтому их возможно пересоздать.
Единственным тонким моментом остаются переменные полчуаемые в конструкторе.
Естествееным желанием является скопировать эти переменные из конструктора
класса \textbf{C}, но в случае публичных переменных возникнет коллизия имен.
Чтобы обойти это ограничение, достаточно продублировать переменные в конструкторе
с другими именами, а потом произвести соответсвующие присвоения.

\subsubsection{Изменение методов родителя}

Последняя рассмотренная здесь сложность будет вызвана инкапсуляцией.
Конкрентно, класс может вызвать super методы его родителя, но не может вызвать
их реализаии у прародителя.
Как это относится к нашему случаю?
Если в коде класса \textbf{C} найдется вызов метода его родителя,
а сам этот метод окажется перегружен, то у нас не будет возможности в
инструментированном коде сделать соответсвующий вызов.
А вышеупомянутый \textbf{MethodResolveProcessor} этим грешит.
Чтобы справится с этой проблемой приходится находить подобные методы и
вставлять в \textbf{C} их заместителей, которые и будут вызываны в \textbf{\$I}.

\subsubsection{Анализ предложенного решения}

В случае с классом мы получаем избыточность сразу во многих местах:
дополнительный класс, дополнительные методы-заместители, возможно исключение
модификатора \textbf{final} для наследования.
Это усложняет работу виртуальной машины java и может делать невозможными
некоторые отимизации.


\begin{lstlisting}[caption={До применения макроса},label=lst:before]
final class C(val a: Int, i: Option[I]) extends Base(a) {
  override def v: Int = {
    i.foreach(_.log(v))
    super.v + 1
  }
}
\end{lstlisting}

Также для наглядности приведен примеры кода с до обработки
макросом~\ref{lst:before}
и после~\ref{lst:after}.

\begin{lstlisting}[caption={После применения макроса},label=lst:after]{Name}
class C(val a: Int) extends Base(a) {
  override def v: Int = super.v + 1
  def superV$I = super.v
}

object C {
  class $I(val a$I: Int, i: Option[I]) extends C(a$I) {
    override def v: Int = {
      i.foreach(_.log(v))
      superV$I + 1
    }
  }
}
\end{lstlisting}


На этом часть связанная с инструментированием кода и макросами заканчивается.
Все вышеописанное можно посмотреть в коде.
Логика обработки АСД находится в
\textbf{org.jetbrains.plugins.scala.macroAnnotations.uninstrumentedMacro}.
Сама же аннотация называется \textbf{uninstrumneted}, она принимает в качестве
аргумента название параметра, соответсвующего объекту инструментации.

% \subsection{Сохраненные данные и визуализация}
% \label{sec:data}
%
% \textbf{переписать}
%
% Здесь мы немного поговорим о визуализации накопленных данных,
% и о том в каком виде эти данные удобно хранить.
%
% Было решено визуализировать данные в виде вложенных вкладок.
% Для этого было две причины.
% Во первых, сходимость типов удобно иллюстрировать деревьями вывода,
% о чем будет рассказано в разделе~\ref{sec:conformance}.
% Во вторых, можно ориентироваться на show implicit parameters action
% в scala plugin из раздела~\ref{sec:showImplicit}.
% Там выбор необходимых implicit параметров иллюстрировался тоже с помощью
% вложенных вкладок и это было удобно.
%
% Далее, заметим что для описания древовидных структур, рекурсивных или нет,
% прекрасно подходят алгебраические типы данных, столь популярные функциональном
% программировании.
% Подробнее про них можно почитать в \cite{algebraic_data}.
% В scala есть подходящий для такой абстракции механизм, называемый case class.
% Именно с помощью него мы и будем хранить все необходимые данные.
% А во время визуализации решение что именно нужно отрисовать будет приниматься
% с помощью механизма сравнения с шаблоном.
% В разделе~\ref{sec:conformance} будет пример.
