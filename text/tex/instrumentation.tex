\section{Особенности реализации}
\label{sec:features}
Здесь будет говориться как получать данные о работе того или иного процесса
внутри Scala Plugin.
Здесь и далее под процессом понимается последовательность выборов, принимаемых функциями и
классами внутри Scala Plugin, направленных на решение какой-то задачи.
Для начала нужно определиться, как именно будут получены эти данные.
Сделаем несколько наблюдений:

\begin{itemize}
  \item Чтобы не заниматься обратным анализом и не перереализовывать функциональность плагина,
  отвечающую за работу с типами, разумным выглядит переиспользовать уже существующую кодовую базу.
  \item Данные полученные о процессах нужно будет визуализировать.
  Поэтому хотелось бы их получать как полноценные объекты scala, а не как, скажем,
  набор снимков состояния стэка которые нуждаются в последующей обработке.
  Для этого формирование этих объектов должно быть отражено в коде рассматриваемых процессов.
  \item Scala Plugin написан на языке программирования scala.
  И хоть scala позициоирует себя как язык с функциональной направленностью,
  однако большая часть кода в плагине, необходимая для анализа процессов связанных с типами,
  написана в императивном стиле.
  То есть используются изменяемые состояния объектов, функции не всегда являются чистыми,
  а поток управления часто прерывается ключевым словом return.
  Поэтому во время получения данных было бы удобно пользоваться изменяемым состоянием.
\end{itemize}

В таких условиях разумной выглядит идея инструментировать фрагменты Scala Plugin,
отвечающие за интересующие нас процессы.
А именно, помещать в контекст выполнения процесса специальные объекты,
которык будут хранить данные о текущем состоянии процесса,
работа с которыми будет описана прямо в коде плагина, и которые
далее мы будем называть объектами инструментации.
Подробно это будет рассмотрено в разделе~\ref{sec:instrumentation}.

% todo рабочее
Однако, не стоит забывать, что Scala Plugin - это рабочее приложение
с большим количеством пользователь.
А код отвечающий за работу с типами, как минимум за сведение типов,
выполняется в плагине на каждом шагу.
Поэтому внесение дополнительных действий в этот код окажет пагубное воздействие
на производительность всего плагина.
Чтобы уменьшить воздействие инструментирования на процесс выполнения остального кода,
в данной работе принято решение использовать макросы.
Обзор возможностей макросов в scala приведен в разделе~\ref{sec:macroScala}.
Их применение к инструментированию на примере инструментированных функций
будет расммотрено в разделе~\ref{sec:macroScala}, а распространение на классы
в разделе~\ref{sec:macroClass}.

В конце будет раздел~\ref{sec:data}, посвященный формату хранения данных.

\subsection{Инструментирование}
\label{sec:instrumentation}

Здесь мы составим набор правил для использования инструментации так,
будто макросов нет.
Это позволит нам запускать код даже без них.
А в последующих разделах мы увидим что построенная система хорошо подходит
для анализа на уровне исходного кода.

Принцип, которым мы будем руководствоваться - инструментация должна быть опциональной.
Это означает что для запуска инструментированной версии кода нужно приложить
какие-то усилия, внешний код не обязан знать что возможно инструментирование.
Если ее не включить, влияние инструментирования на классы и функции будет
максимально снижено, поведение будет таким, каким было до инструментирования.

Попробуем представить как должно выглядеть инструментирование для, скажем, функции f.
Нам необходимо передать объект инструментации внутрь функции и дать знать,
нужно ли его использовать.
Это можно сделать или с помощью двух дополнительных параметров функции:
объекта и флага, или с помощью одного дополнительного параметра объекта,
который может принимать значение null.
Но в функциональном программировании есть более выразительное средство -
монада Option.
Значение по умолчанию None позволит не изменять уже существующие вызовы функции f.

\begin{lstlisting}[caption={Явная передача объекта инструментации внутрь функции}]
def f(..., instrumentation: Option[Instrumentation] = None)
\end{lstlisting}

Option и его функции высшего порядка такие как map и foreach автоматически дают нам
контекст, в котором мы можем выполнять любые необходимые действия,
в области видимости которого есть, непосредственно, объект инструментирования,
и которые игнорируются если Option оказался пуст.

\begin{samepage}
\begin{lstlisting}[caption={Действия внутри контекста инструментации}]
instrumentation.foreach { i =>
  val a = computeA
  i.addInformation(a)
}
\end{lstlisting}
\end{samepage}

\textit{
Option для нас - это контекст, в котором живут все объекты и действия необходимые
для сбора данных. Покидать этот контекст им запрещено.
???
Написать Some как контекст.
}

Теперь поймем как хранить данные которые изменяются со временем.
Понятно что мы можем их хранить внутри объекта инструментации, и у нас нет другого
выхода если эти данные обновляются внутри вложенных вызовов функций.
Однако один и тот же объект инструментирования может появляться в множестве разных
частей программы и включение в него логики обработки промежуточных данных для
всех этих случаев может показаться избыточным.
Решением будет вынесение этих данных в изменяемую переменную.
Однако, мы хотим чтобы действия над этой переменной зависели от наличия объекта
инструментации.
В примере ниже показано как это сделать используя функцию map.

\begin{samepage}
\begin{lstlisting}[caption={Привязка к контексту инструментации}]
var intermediate = instrumentation.map(_ => Seq.empty[R])
for (i <- 0 to n) {
  val r = findResultFor(i)
  intermediate = intermediate.map(_ :+ r)
  doSomeStuff(r)
}
\end{lstlisting}
\end{samepage}

Таким образом мы явно связали переменную intermediate с контекстом instrumentation
в кототом и выполняется инструментация.
Аналогичным приемом можно воспользоваться если необходимо завести неизменяемы данные
вне контекста инструментации.
Это может понадобиться когда для вложенного вызова объект инструментации изменяется.

\begin{samepage}
\begin{lstlisting}[caption={Создание нового объекта инструментации}]
val inner = instrumentation.map(_.inner)
g(..., instrumentation = inner)
instrumentation.foreach(_.add(inner.get.data))
\end{lstlisting}
\end{samepage}

\textit{При возникновении новых сущностей связанных с
инструментированием, мы явно устанавливаем связь с уже существующими объектами.}

Разумным требованием кажется избегать влияния влияние интрументирования на
логику функции.
Но так ли это?
Рассмотрим в качестве примера проверку сводимости двух параметризованных типов.
Для сводимости одного типа к другому необходимо чтобы количества типовых параметров
совпадали и для каждой пары соответствущих типовых параметров выполнялось определенное соотношение.
При проверке этих соотношений достаточно дойти до первого ложного чтобы понять что
сводимость нет, что плагин и делает.
Однако в целях отладки было бы более информативно проверить все соотношения чтобы дать
пользователю более полную картину.

Таким образом возможность изменять поведение изначальной функции нам нужна.
Однако, есть версия что достаточно уметь делать две вещи:
изменять выбранную вертку исполнения в условных конструкциях при включенной
инструментировации, а также избегать прерывания потока исполнения ключевым словом return.

Основной идеей будет то что квантор всеобщности над пустым множеством всегда
верен, а квантор сущестования нет.
Таким образом мы можем использовать логику основанную на \textbf{существовании} объекта
в связке с \textbf{логическим или}, а также что-то для \textbf{любого} объекта
в связке с \textbf{логиеским и}.
Также заметим что любую конструкцию, тип которой Unit, такую как return,
мы можем записать через if (true).

Пример ниже иллюстрирует это.
В нем мы мы сначала игнорируем кэшированное значения с помощью проверки,
возвращающей false на непустом множестве.
Далее функции computeA и computeB из которых мы извлекаем данные.
Чтобы не прерываться после неудавшейся проверки conditionA, мы добавляем
условный оператор.
Если instrumentation пуст, то forall вернет true и поток исполнения прервется.
В обратном случае выполнится interrupt, который поднимет флаг остановки, а
forall вернет false и поток исполнения продолжится.
В конце мы с помощью exists проверяем был ли поднят флаг прерывания в процессе работы,
и если бы то возвращаем соответствующее значение.

\begin{lstlisting}[caption={Влияние на первоначальную логику}]
val cached = cache.get(key)
if (cached != null && instrumentation.isEmpty) return cached

val conditionA = computeA(instrumentation = instrumentation)
if (conditionA)
  if (instrumentation.forall(!_.interrupt())) return false
val conditionB = computeB(instrumentation = instrumentation)
if (instrumentation.exits(_.interrupted())) return false
return conditionB
\end{lstlisting}

До этого момента мы говорили только о функциях.
Достаточно ли нам уметь работать только с ними?
Вообще говоря достаточно, но работать только с функциями неудобно.

Встречаются классы которые выступают как контейнеры функций.
Примерами могут служить классы MostSpecificUtil и MethodResolveProcessor.
Вместо того чтобы добавлять по параметру с объектом инструментации в каждый
метод, намного проще добавить один парметр в их конструкторы.
В будущем это усложнит задачу написания макроса.

\subsection{Макросы в scala}
\label{sec:macroScala}

Прежде чем говорить о макросах в scala, следует понять что имеется в виду под словом макрос.
Изначально, макрокоманда или макрос -- это символьное имя,
заменяемое при обработке исходного кода препроцессором на некоторый текст.
Наиболее известный пример макросов можно встретить в препроцессорах языков
программирования C и C++.

Подобные макросы работают по следующему механизму.
В начале пользователь описывает с помощью специального синтаксиса функцию,
которая примнимает в качестве параметров строковые константы, а возвращает текст,
в который могут быть подставлены значения этих параметров.
Перед компиляцией текста препроцессор проходит по тексту исходного кода и заменяет
вызовы этих функций на соответсвующие значения.
Как простые строки, без каких-либопроверок.
И только после этого, полученный текст отдается компилятору.

Использование макросов в scala контрастирует с вышеописанным подходом.
Главным отличием является то, что макросы в scala работают не со строками,
а с абстрактными синтаксическими деревьями, представляющими исходный код
программы.
Scala макросы пишутся на полноценном scala и являются функциями, принимающими
АСД фрагментов исходного кода и возвращающие АСД фрагментов которые нужно
сгенерировать.
То есть для того чтобы применить макрос к коду, компилятору требуется построить
АСД этого кода. Тем самым макросы не изменяют изначальный синтаксис, а лишь
преобразуют фрагменты кода.

\subsubsection{Macro Paradise}

Обычно такие макросы используют чтобы автоматически генерировать что-то для
класса, например сериализаторы.
И эти возможности предоставляет сам компилятор.
Однако существует плагин к компилятору Macro Paradise, который позволяет не
просто создавать новый код, но и заменять существующий.
Именно эту возможность мы и будем использовать для того чтобы снизитить влияние
кода инструментации на процесс исполнения.

Для того чтобы использовать Macro Paradise нужно создать специальную аннотацию,
которой должны быть помечены функции и классы код которых мы хотим изменить.
В класс этой аннотации должен быть добавлен код функции-генератора АСД.

Теперь поймем, чего мы хотим добиться используя кодогенерацию.
С одной стороны мы бы хотели полностью избавиться от кода связанного с инструментацией,
чтобы он никак не влиял на производительность плагина.
С другой стороны, эта инструментация добавлялась не просто так.
Выходом будет сгенерировать две копии каждой функции: одну с инструментацией,
другую без.
То же самое для классов.

Опишем более подробно как именно это будет происходить.

\subsection{Макросы для функций}
\label{sec:macroFunction}

Сформулируем правила инструментирования полученные в
разделе~\ref{sec:instrumentation}:
\begin{enumerate}
  \item
  \label{itm:ins-constructor}
  Объект инструментирования передается явно как параметр функции или
  конструктора классов в монаде Option со значением по умолчанию None.
  \item
  \label{itm:ins-context}
  Действия связанные с инструментированием не должны покидать контекст
  инструментирования.
  \item
  \label{itm:ins-creating}
  Создание нового контекста инструментации происходит явно от другого,
  уже существующего, контекста инструментирования.
  Для этого подходит функция функция map.
  \item
  \label{itm:ins-logic}
  Для того чтобы влиять на первоначальную логику добавляются условные
  инвариантные для пустого контекста инструментизации условия.
\end{enumerate}



В этом разделе наша задача - по коду инструментированной функции f сгенерировать
пару новых функций \textbf{f} и \textbf{f\$I}.
Здесь \textbf{f} - это замена старой функции в которой будет удалено
все инструментирование.
\textbf{f\$I} - функция в которой оставлена инструментация.

\begin{algorithm}
  \caption{Обновление информации о контекстах инструментизации}\label{alg:names}
  \begin{algorithmic}[1]
    \Function{UpdateInstrumentationNames}{$codeBlock, previousNames$}
    \State $names \gets previousNames$
    \For {$expr \gets$ выражения внутри $codeBlock$}
    \If {$expr$ объявление символа $n$ с использованием $names$}
    \State $names \gets names$ добавить $n$
    \ElsIf {$expr$ объявление символа $n$}
    \State $names \gets names$ убрать $n$
    \EndIf
    \EndFor
    \State \Return names
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\subsubsection{Поиск инструментации}

Мы рассмотрим процесс генерации на очень концептуальном уровне.
И прежде всего нам потребуется вспомогательная функция
\textbf{GetInstrumentationNames} из алгоритма~\ref{alg:names}.

\textbf{Редактура!!!}

Эта функция нужна для обновления информации об именах связанных с инструментацией.
Теперь нам нужно найти новые созданные контексты инструментации внутри
тела \textbf{f}.
Это не сложно сделать, так как по пункту~\ref{itm:ins-creating} связь между ними
и старыми контекстами отслеживается в коде явно.
Имея множество имен, содержащих объекты инструментации мы можем находить новые
переменные созданные с помощью этих имен и функции map, а после добавлять их в
множество.

\subsubsection{Генерация неинструментированной функции}

Теперь перейдем к рассмотрению генерации не инструментированной функции.

\begin{algorithm}
\caption{Генерация неинструментированной функции}\label{alg:nonins}
\begin{algorithmic}[1]
\Function{GetNonInstrumentedFunction}{$func, parameterName$}
  \State удалить $parameterName$ из сигнатуры функции $func$
  \State $codeBlock \gets$ получить тело $func$
  \State $HandleNonInstrumentedBlock(codeBlock, parameterName)$
\EndFunction

\Function{HandleNonInstrumentedBlock}{$codeBlock, previousNames$}
  \State $names \gets UpdateInstrumentationNames(codeBlock, previousNames)$
  \For {$expr \gets$ выражения внутри $codeBlock$}
    \If {$expr$ это условние в котором есть только элемент из $names$}
      \State заменить все условное выражение на одну из ветвей
    \ElsIf {$expr$ это условие содержащее элемент из $names$}
      \State упростить условие, исключив из него элементы из $names$
    \ElsIf {$expr$ это вызов с использованием элемента из $names$}
      \State удалить аргументы связанные с $names$ из вызова
    \ElsIf {$expr$ основан на элементе из $names$}
      \State удалить $expr$
    \ElsIf {$expr$ это новый блок кода}
      \State $HandleInstrumentedBlock(expr, names)$
    \ElsIf {$expr$ содержит элемент из $names$}
      \State \Return ошибка
    \EndIf
  \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Генерация инструментированной функции}\label{alg:ins}
\begin{algorithmic}[1]
\Function{GetInstrumentedFunction}{$func, parameterName$}
  \State добавить к названию функции $func$ суффикс $\$I$
  \State $codeBlock \gets$ получить тело $func$
  \State $HandleInstrumentedBlock(codeBlock, parameterName)$
\EndFunction

\Function{HandleInstrumentedBlock}{$codeBlock, previousNames$}
  \State $names \gets UpdateInstrumentationNames(codeBlock, previousNames)$
  \For {$expr \gets$ выражения внутри $codeBlock$}
    \If {$expr$ это вызов с использованием элемента из $names$}
      \State добавить к имени символа суффикс $\$I$
    \ElsIf {$expr$ это новый блок кода}
      \State $HandleNonInstrumentedBlock(expr, names)$
    \EndIf
  \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

Функция \textbf{GetNonInstrumentedFunction} из алгоритма~\ref{alg:nonins}
выполняет искомую задачу.

По пункту~\ref{itm:ins-constructor} среди параметров этой функции должен быть
объект инструментации.
Допустим что нам известно его имя.
В первую очередь удаляем его.

Удалить действия связанные с инструментацией тоже не сложно.
Все они, по пункту~\ref{itm:ins-context}, находятся в соответствущих контекстах
связанных с именами объектов,а множество имен объектов у нас есть.
Заодно из кода вырезаются передачи этих объектов в вызовы функций.
Именно для этого требовалась явная передача аргументов.
Несмотря на то что можно было воспользоваться механизмом implicit,
нам бы потребовалась помощь компилятора чтобы находить передачу контекста
инструментирования.

Осталось наше влияние на первоначальную логику.
Но оно из пункта~\ref{itm:ins-logic} ограничивается использованием объектов
инструментации в условиях.
Чтобы вернуть все как было достаточно упростить все логические выражения,
подразумевая что используемые в них контексты инструментации пусты.
А также удалить условные конструкции, если они зависят только от объектов
инструментирования.

\subsubsection{Генерация инструментированной функции}

Логика генерации инструментированной функции намного проще.
Здесь нам достаточно изменить название самой функции и проследить чтобы все
вызовы используюшие инструментации были перенаправлены в инструментированный
код.

Таким образом избыточность создается только из-за увеличения количества функций
доступных для java virtual machine.

Также стоит заметить что применение аннотации к функции автоматически форсирует
нас использовать аннотации на всех вызванных внутри функциях, в которые мы передали
объекты инструментации.
Действительно, в инструментированной версии к этим функциям будет добавлен
суффикс \textbf{\$I} и код не скомпилируется если мы не позаботимся о наличии
соответсвующих функций.

\subsection{Макросы для классов}
\label{sec:macroClass}
Теперь перейдем к рассмотрению работы макро-аннотации класса.
Нашей задча остается прежней - по классу \textbf{C} сгенерировать пару:
инструментированный класс и неинструментированный.

Прежде всего заметим, что все относящееся к обработке инструментации внутри
функции также верно и для класса.
Здесь нас будут интересовать проблемы при создании классов, а также методы
их преодаления.
До этого момента все было хорошо.
Это связано с тем что функция не несет в себе состояния.
Она не участвует ни в каких иерархиях и для нее понятие инкапсуляции абсолютно.

\subsubsection{Создание дополнительного класса}

Однако первая проблема с которой мы столкнемся будет не проблема наследования,
а сообщение Macro Paradise
"error: top-level class with companion can only expand into a block consisting
in eponymous companions".
Проблема заключается в следующем, Macro Paradise не добавляет новые имена в
верхний уровень видимости.
Единственное исключение - для класса можно сгенерировать его объект-компаньон.
В нашем же случае почти все классы вызывающие интерес лежат в верхнем уровне
видимости.

Что же, воспользуемся единственным исключением и вместо инструментированного
класса \textbf{C\$I} создадим инструментированный класс \textbf{\$I} который
будет лежать в объекте-компаньоне \textbf{C}.
Это решит проблему появления глобальных имен, и вызовы конструктора класса
\textbf{new C} в инструментированной версии будут перенаправляться
в \textbf{new C.\$I}.

\subsubsection{Наследование}

Следующей проблемой будет - кто являются родителями \textbf{\$I}.
Кажется разумным выбрать тех же родителей что и у \textbf{C}.
Это правда пока не появляется функция принимающая \textbf{C} и вызываемая
внутри инструментрованного кода.
В качестве примера можно привести класс \textbf{MethodResolveProcessor}
который передает себя в метод \textbf{candidates} объекта-компаньона
через \textbf{this}.
Можно попытаться сгенерировать две копии метода \textbf{candidates},
но в таком случае становится сложнее отслеживать распространение контекста
инструментирования.
То что было описано в разделе~\ref{sec:instrumentation} перестает работать.
А за счет возможности импортировать имена из объектов (которой воспользовались
в плагине), без помощи компилятора даже нельзя понять, какие вызовы относятся
к тому что мы передали, а какие нет.

Остается наследование от \textbf{C}, чтобы номинальная система типов не могла
отличить от него \textbf{\$I}.

\subsubsection{Внутреннее состояние}

В начале поговрим о внутреннем состоянии класса.
Данные хранятся в переменных, изменяемых или неизменяемых.
А эти переменные могут быть или публичными, или приватными.
Часть из них объявлена в конструкторе.
Помимо этого у класса может быть инициализаци, которая может содержать побочные
эффекты.

Самое первое - нужно запретить инициализацию объекта.
С одной стороны из-за принципа инкапсуляции мы не можем проигнорировать
конструктор класса \textbf{C}.
С другой, если там должна была быть инструментация, то нам нужно перезапустить
конструктор в классе \textbf{\$I}, но уже с инструментацией.
Это может привести либо к несогласованности внутри класса, либо, если есть
побочные эффекты, к неожиданным внешним явлениям.
Самое простое - запретить общую инициализацию объекта, оставив передачу параметров.
Причем, оказывается что в нашем случае это не очень большое ограничение.
Как говорилось в начале раздела, нас интересуют классы являющиеся упаковками
функций.
В них отсутсвует секция инициализации и так.

Теперь нужно разобраться с переменными класса.
Если нет инициализации, то публичные переменные класса \textbf{C} мы можем
просто переиспользовать в методах класса \textbf{\$I}.
Приватные переменные же переменные класса \textbf{C} не покидают его область
видимости, поэтому их достаточно продублировать.
Единственным тонким моментом остаются переменные полчуаемые в конструкторе.
Естествееным желанием является скопировать эти переменные из конструктора
класса \textbf{C}, но в случае публичных переменных возникнет коллизия имен.
Чтобы обойти это ограничение, достаточно продублировать переменные в конструкторе
с лругими именами, а потом провести соответсвующие присвоения.

\subsubsection{Изменение методов родителя}

Последняя рассмотренная здесь сложность станет вызвана инкапсуляции.
Конкрентно, класс может вызвать super методы его родителя, но не может вызвать
их реализаии у прародителя.
Как это относится к нашему случаю?
Если в коде класса \textbf{C} найдется вызов метода его родителя,
а сам этот метод окажется перегружен, то к нас не будет возможности в
инструментированном коде сделать соответсвующий вызов.
А вышеупомянутый \textbf{MethodResolveProcessor} этим грешит.
Чтобы справится с этой проблемой приходится находить подобные методы и
вставлять в \textbf{C} их заместителей, которые и будут вызываны в \textbf{\$I}.

\textbf{Пример класс до, класс после.}

\begin{lstlisting}[caption={До применения макроса}]{Name}
final class C(val a: Int, i: Option[I]) extends Base(a) {
  override def v: Int = {
    i.foreach(_.log(v))
    super.v + 1
  }
}
\end{lstlisting}

\begin{lstlisting}[caption={После применения макроса}]{Name}
class C(val a: Int) extends Base(a) {
  override def v: Int = super.v + 1
  def superV$I = super.v
}

object C {
  class $I(val a$I: Int, i: Option[I]) extends C(a$I) {
    override def v: Int = {
      i.foreach(_.log(v))
      superV$I + 1
    }
  }
}
\end{lstlisting}

В случае с классом мы получаем избыточность сразу во многих местах:
дополнительный класс, дополнительные методы-заместители, возможно исключение
модификатора final для наследования.
Это усложняет работу виртуальной машины и может делать невозможными некоторые
отимизации.

На этом часть связанная с инструментированием кода и макросам заканчивается.
Все вышеописанное можно посмотреть в коде плагина.
Логика обработки АСД находится в
\textbf{org.jetbrains.plugins.scala.macroAnnotations.uninstrumentedMacro}.
Сама же аннотация называется \textbf{uninstrumneted}, она принимает в качестве
аргумента название параметра, соответсвующего объекту инструментации.

\subsection{Сохраненные данные и визуализация}
\label{sec:data}

\textbf{переписать}

Здесь мы немного поговорим о визуализации накопленных данных,
и о том в каком виде эти данные удобно хранить.

Было решено визуализировать данные в виде вложенных вкладок.
Для этого было две причины.
Во первых, сходимость типов удобно иллюстрировать деревьями вывода,
о чем будет рассказано в разделе~\ref{sec:conformance}.
Во вторых, можно ориентироваться на show implicit parameters action
в scala plugin из раздела~\ref{sec:showImplicit}.
Там выбор необходимых implicit параметров иллюстрировался тоже с помощью
вложенных вкладок и это было удобно.

Далее, заметим что для описания древовидных структур, рекурсивных или нет,
прекрасно подходят алгебраические типы данных, столь популярные функциональном
программировании.
Подробнее про них можно почитать в \cite{algebraic_data}.
В scala есть подходящий для такой абстракции механизм, называемый case class.
Именно с помощью него мы и будем хранить все необходимые данные.
А во время визуализации решение что именно нужно отрисовать будет приниматься
с помощью механизма сравнения с шаблоном.
В разделе~\ref{sec:conformance} будет пример.
