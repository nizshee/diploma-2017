\stepcounter{section}
\hfill ПРИЛОЖЕНИЕ А
\begin{center}
  \textbf{Алгоритмы обработки инструментрованных функций}
\end{center}
\markboth{\MakeUppercase{}}{}
\addcontentsline{toc}{section}{Приложение А. Алгоритмы обработки инструментрованных функций}

\begin{algorithm}
\caption{Обновление информации о контекстах инструментизации}\label{alg:names}
\begin{algorithmic}[1]
\Function{UpdateInstrumentationNames}{$codeBlock, previousNames$}
  \State $names \gets previousNames$
  \For {$expr \gets$ выражения внутри $codeBlock$}
    \If {$expr$ объявление символа $n$ с использованием $names$}
      \State $names \gets names$ добавить $n$
    \ElsIf {$expr$ объявление символа $n$}
      \State $names \gets names$ убрать $n$
    \EndIf
  \EndFor
  \State \Return names
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Генерация неинструментированной функции}\label{alg:nonins}
\begin{algorithmic}[1]
\Function{GetNonInstrumentedFunction}{$func, parameterName$}
  \State удалить $parameterName$ из сигнатуры функции $func$
  \State $codeBlock \gets$ получить тело $func$
  \State $HandleNonInstrumentedBlock(codeBlock, parameterName)$
\EndFunction

\Function{HandleNonInstrumentedBlock}{$codeBlock, previousNames$}
  \State $names \gets UpdateInstrumentationNames(codeBlock, previousNames)$
  \For {$expr \gets$ выражения внутри $codeBlock$}
    \If {$expr$ это условние в котором есть только элемент из $names$}
      \State заменить все условное выражение на одну из ветвей
    \ElsIf {$expr$ это условие содержащее элемент из $names$}
      \State упростить условие, исключив из него элементы из $names$
    \ElsIf {$expr$ это вызов с использованием элемента из $names$}
      \State удалить аргументы связанные с $names$ из вызова
    \ElsIf {$expr$ основан на элементе из $names$}
      \State удалить $expr$
    \ElsIf {$expr$ это новый блок кода}
      \State $HandleInstrumentedBlock(expr, names)$
    \ElsIf {$expr$ содержит элемент из $names$}
      \State \Return ошибка
    \EndIf
  \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Генерация инструментированной функции}\label{alg:ins}
\begin{algorithmic}[1]
\Function{GetInstrumentedFunction}{$func, parameterName$}
  \State добавить к названию функции $func$ суффикс $\$I$
  \State $codeBlock \gets$ получить тело $func$
  \State $HandleInstrumentedBlock(codeBlock, parameterName)$
\EndFunction

\Function{HandleInstrumentedBlock}{$codeBlock, previousNames$}
  \State $names \gets UpdateInstrumentationNames(codeBlock, previousNames)$
  \For {$expr \gets$ выражения внутри $codeBlock$}
    \If {$expr$ это вызов с использованием элемента из $names$}
      \State добавить к имени символа суффикс $\$I$
    \ElsIf {$expr$ это новый блок кода}
      \State $HandleNonInstrumentedBlock(expr, names)$
    \EndIf
  \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}
