\section{Обзор}
\label{overview}

% В последнее время стало появлятся много новых языков программирования.
На данный момент scala является достаточно известным языком программирования
интерес к которому быстро растет.
Одной из важных особенностей scala является его желание элегантно объединить
объектно-ориентированное программирование с, набирающей популярность,
функциональной парадигмой.

В данной работе нас будет интересовать функциональная направленность scala.
К ней можно отнести: функции высших порядков, использование механизма
pattern matching или отдание предпочтения неизменяемым данным.
А также использование достаточно продвинутой системы типов.

Можно отметить следующие особенности системы типов scala:
\begin{itemize}
  \item Чтобы найти применение в промышленном программировании scala изначально
  создавался как язык совместимый с java.
  Это ведет к возможности использования классов java, а следовательно и типы
  из java являются допустимыми типами внутри scala.
  \item Унифицированная система типов. Все типы, начиная с типов функций или
  классов и заканчивая типами пришедшими из java входят в единую иерархию типов.
  Это отличается от того же java где ссылочные типы отделены от примитивных.
  Наибольшим типом в этой иерархии является \textbf{Any}, а наименьшим
  \textbf{Nothing}.
  \item Стандартным методом достижения переиспользования кода
  в функциональных языках является различного рода полиморфизм.
  В scala есть возможность как абстрагировать по типу части кода,
  например полиморфные методы, так и сами типы.
  К последнему случаю относятся конструкторы типов и параметризованные типы.
  В случае с конструктором типа есть возможность указать не только ограничения
  на передаваемые в него типы, но и вариантности.
  От них зависит как сводимость типовых аргументов скажется на
  сводимости полных типов.
  Например, \textbf{List[Derived]} сводится к \textbf{List[Base]}, если
  \textbf{Derived} сводится к \textbf{Base}.
  \item В scala можно абстрагироваться не только по полноценному типу,
  но и по конструктору типа.
  Это дает поддержку так называемых типов высших кайндов.
  \item Пожалуй, главной особенностью scala является механизм implicit у которого
  есть множество различных применений.

  Например, для метода часть его параметров можно пометить как неявные.
  В таком случае можно не передавать соответствующие аргументы явно.
  Компилятор сам выполнит поиск подходящих по типу неявных переменных,
  а после использует их в качестве аргументов.
  В комбинации с типами высших кайндов это позвоялет достичь ad-hoc полиморфизма,
  когда новая функциональность добавляется в класс без изменения самого
  класса.
  \item Также есть другие сущности пришедшие из теории типов:
  структурные типы, экзестенциальные типы, типы завиящие от пути...
\end{itemize}

В сложности системы типов есть как плюсы, так и минусы.
С одной стороны это повышает надежность кода кода за счет увеличения статичеких
проверок, приводя к, так называемой, типобезопасности.
Однако вместе с этим усложняется использование языка, а описание типовых
конструкций может стать громоздким.
Чтобы бороться с последним, компилятор предлагает не только выполнять проверки
типов, но выводить большинство типов самомтоятельно.

Часто нет необходимости явно указывать тип переменной, компилятор может
сам его вывести используя выражение в правой части.
Также может быть необязательно явно передавать типовые аргументы в полиморфную
функцию, компилятор может сам сделать неявное преобразование.

Однако все что связано с типобезопасностью компилятор делает неявно для пользователя.
А в случае несовпадения типов где-то, он просто выводит сообщение вида:
тип ожидался, тип найден.
И далеко не всегда просто понять в чем именно заключалась ошибка.
Нас будет интересовать возможность как проиллюстрировать процесс выведении типов,
так и процесс проверки типов в общем.

% Поэтому компилятор может дописывать типы за пользователя.
% Компилятор может выводить типы за пользователя, что особенно удобно с
% использованием лямбда-функций.
% Т.е. типы не указываются явно, а компилятор делает неявное преобразование.

% Хотелось бы исеть штуку, которая поможет с этим.

Как будет видно в дальнейших, инструменты связанные с отладкой типов часто
требуют специальные версии компилторов для своей работы.
Заметим что интегрированные среды разработки должны выполнять ту же работу по
работе с типами что и компилятор.
Действительно, нахождение семантических ошибок требует знания о типах.
Поэтому отладчик типов можно основывать не на компиляторе, а на ИСР.
А создание подобного инструмента в уже существующей среде, цель которой
облегчить написание кода, кажется разумной идеей.
Существуют две популярные ИСР для scala: Scala Plugin для intellij idea и
плагин scala IDE для eclipse.
Далее мы будем говорить про Scala Plugin в intellij idea.

\subsection{Отладчик типов для языка программирования OCaml}
\label{sec:ocaml}
В качестве примера отладчика типов рассморим проект Type Debugger для
языка программирования OCaml.

OCaml, как и большинство функциональных языков, использует мощную статическкую
типизацию, и, так же как в scala, компилятор берет на себя работу по выводу типов
не указанных явно.
Представим ситуацию, во время вывода типов компилятор OCaml находит противоречие:
одно подвыражение требует один тип, а другое предоставляет отличный.
В таком случае принятие решения о том какой тип на самом деле подразумевался
пользователем становится проблематичным.
Поэтому компилятор выбирает тип как-то и выдает сообщение об ошибке.

Type Debugger, призван помочь разработчикам на OCaml получать более
конструктивную информацию об ошибках во время вывода типов.
В ситуациях несовпадения типа он начинает задавать
вопросы пользователю, какой тип подразумевался у того или иного выражения.
По результатам ответов на эти вопросы Type Debugger понимает источник проблемы
и дает пользователю более конкрентые источник ошибки.

Отдельно стоит заметить, что для реализации подобной функциональности
Type Debugger для OCaml переиспользует код вывода типов в компиляторе OCaml.

Подобный проект создает прецедент существования отладчиков типов.

\subsection{Scala type debugger}
\label{sec:typeDebugger}

Возникает лаконичный вопрос - существует ли подобный инструмент для языка
программирования scala.
Ответ - да, существует.
Проект называется scala type debugger, и для ознакомления с ним можно посмотеть
репозиторий на github~\cite{type_debugger_github} и несколько
статей~\cite{type_debugger1}~\cite{type_debugger2}, одна из которых
написана в соавторстве с Мартином Одерски, создателем языка scala.

Цель этого инструмента анализировать проблемы связанные с типами.
Результатом его работы будет граф, где в вершинах записаны действия выполняемые
компилятором при типизации какого-то выражения, а также их результат.
По этому графу можно понять что делал компилятор для проверки типов и
в какой именно момент возникла ошибка.

Так как это прямой конкурент, то разберем что именно нас не устраивает в данном
проекте:
\begin{itemize}
  \item Так же как и Type Debugger для языка OCaml, scala type debugger
  переиспользует код компилятора scala.
  Для своей работы он требует специально инструментированную версию scalac.
  Это не очень удобно, нужно перенастраивать окружение под соответсвующую версию
  компилятора.
  При этом нашей целью является создать отладчик типов внутри Scala Plugin.
  Scala Plugin же занимается анализом кода самостоятельно и использует
  свое собственно внутреннее представление типов.
  Добавление некоего инструментированного компилятора создаст лишнюю зависимость.
  \item На момент написания работы репозиторий со scala type debugger не
  обновлялся в течение 5 лет.
  В статье~\cite{type_debugger1} написано о планах интегрировать его в eclipse.
  Но до сих пор этого не было сделано.
\end{itemize}

% Если же написать инструмент для анализа проверок типов основываясь исключительно
% на коде Scala Plugin, то для использования такого инструмента не будет никаких
% проблем.

\subsection{Show implicit parameters action}
\label{sec:showImplicit}

В заключение рассмотрим уже существующий в Scala Plugin инструмент, который
помогает пользователю разобраться в дейтсвиях компилятора.

В начале раздела уже описывалась работа механизм implicit параметров.
Существуют определенные правила поиска соответвствующих параметров,
но так как в коде это явно не указываются, часто этот механизм
может работать не вполне предсказуемо.
Ситуация осложняется существованием функций производящих неявные значения
используя другие неявные параметры и так далее.

Чтобы помочь облегчить работу с implicit парметрами в Scala Plugin существует
show implicit parameters action~\cite{show_implicit}.
Он в виде вложенных вкладок отрисовывает дерево, где узел - это функция требующая
неявные параметры, а лист - это неявная переменая.
Это дерео позволяет быстро навигироваться по коду.

Вообще говоря, многие процессы удобно визуализировать как деревья.
Забегая вперед, в данной работе будет использоваться такой-же стиль
представления информации как и у show implicit parameters action.

\subsection{Постановка цели}

На данный момент мы узнали достаточно чтобы сформулировать цель и задачи.

Цель:
реализовать отладчик процесса проверки типов в Scala Plugin.

Для этого можно выделить следующие задачи:
\begin{itemize}
  \item Инструментировать Scala Plugin для сбора данных о процессе работы с типами.
  \item Дать интерпретиацию приближенную к спецификации.
  \item Минимизировать влияние инструментации во время выполнения на оставшуюся
  часть плагина.
\end{itemize}

Теперь несколько замечаний про цели и задачи.

Несмотря на то что цель звучит достаточно общно, в
разделе~\ref{sec:implementation} будут конкретизированы процессы работы с типами
вызывающие интерес.

В разделе~\ref{sec:features} будет более подробно
рассказано почему в качестве способа сбора данных было выбрано именно
инструментирование исходного кода плагина.
Там же описана важность уменьшения влияния инструментации во время исполнения.

Также не получится целиком давать интерпретацию данных основываясь на спецификации
потому что плагин порою ей не следует.

Можно привести три случая непостредственной пользы подобного инструмента:
\begin{itemize}
  \item Понизить сложность вхождения.
  Как говоилось выше, у scala не самая простая система типов и разобраться
  в ней новичку может быть не просто.
  Данный инструмент позволит явно визуализировать работу с типами, которую
  производит Scala Plugin.
  \item Нетривиальные случаи.
  Хотя принцип работы будет основан на коде Scala Plugin а не scalac,
  существуют неочевидные ошибки не завязанные на специфике компилятора с которыми
  инструмент поможет спраиться.
  В разделе~\ref{sec:overloading} будет дан пример такой ситуации.
  \item Внутреннее использование.
  Для людей которые должны работать с внутренним устройством плагина это может
  дать представление о происходящем внутри без необходимости непосредственной
  отладки.
\end{itemize}
