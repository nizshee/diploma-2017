\section{Обзор}

Scala является популярным языком программирования.

Система типов.

Скала использует многоие штуки из теории типов.
\begin{itemize}
  \item Унифицированная система типов
  \item Параметризованные типы
  Вариантность.
  \item Структурные типы
  \item Типы высших кайндов
  \item Implicit
  \item Экзестенциальные типы
  \item Path-dependent types
\end{itemize}

Однако использование широких возможностей системы типы влечет к избыточости.
Все эти типы могут занимать много места.

Поэтому компилятор может дописывать типы за пользователя.
Компилятор может выводить типы за пользователя, что особенно удобно с
использованием лямбда-функций.
Т.е. типы не указываются явно, а компилятор делает неявное преобразование.

If you have, you might have wondered why the OCaml compiler does not produce
better error messages. The reason is: it can't.

Хотелось бы исеть штуку, которая поможет с этим.
Причем лучше чтобы она была доступна в какой-то интегрированной среде разработке.
Заметим что ИСР должны выполнять ту же работу по выводу типов что и компилятор.
Семантические ошибки требуют знания типов.
Существуют две подобные ИСР: Scala Plugin для intellij idea и плагин для
eclipse scala IDE.
Нужно определиться и выбрать одну из них.
Далее мы будем говорить про intellij idea.

Рассмотрим, какие бывают помощники, описывающие работу компилятора.

\subsection{Отладчик типов для языка программирования OCaml}
\label{sec:ocaml}

OCaml, как и большинство функциональных языков, использует мощную статическкую
типизацию, и, так же как в scala, компилятор берет на себя работу по выводу типов
не указанных явно.
Представим ситуацию, во время вывода типов компилятор OCaml находит противоречие:
одно подвыражение требует один тип, а другое предоставляет отличный.
В таком случае принятие решения о том какой тип на самом деле подразумевался
пользователем становится проблематичным.
Поэтому компилятор выбирает тип как-то и выдает сообщение об ошибке.

Сущетвует интересный проект, Type Debugger, призванный помочь разработчикам
на OCaml получать более конструктивную информацию об ошибках во время вывода типов.
В ситуациях несовпадения типа он начинает задавать
вопросы пользователю, какой тип подразумевался у того или иного выражения.
По результатам ответов на эти вопросы Type Debugger понимает источник проблемы
и дает пользователю более конкрентые источник ошибки.

Отдельно стоит заметить, что для реализации подобной функциональности
Type Debugger для OCaml переиспользует код вывода типов в компиляторе OCaml.

Подобный проект создает прецедент существования отладчиков типов.

\subsection{Scala type debugger}
\label{sec:typeDebugger}

Возникает лаконичный вопрос - существует ли подобный инструмент для языка
программирования scala.
Ответ - да, есть.
Можно найти проект scala type debugger, репозиторий которого находится на
github~\cite{type_debugger_github}, и две
статьи~\cite{type_debugger1}~\cite{type_debugger2}, одна из которых
написана в соавторстве с Мартином Одерски, создателем scala.

Цель этого инструмента анализировать проблемы связанные с типами, а также сам
процесс проверки типов в целом.

Так как это прямой конкурент, то разберем что именно нас не устраивает в данном
проекте:
\begin{itemize}
  \item Так же как и Type Debugger для языка OCaml, scala type debugger
  переиспользует код компилятора scala.
  Для своей работы он требует специально инструментированную версию scalac.
  Это не очень удобно, нужно перенастраивать окружение под соответсвующую версию
  компилятора.
  При этом изначальной целью было использовать ... внутри Scala Plugin.
  Scala Plugin же строит занимается анализом кода самостоятельно и использует
  свое внутреннее представление типов
  Добавление некоего инструментированного компилятора создаст лишнюю зависимость.
  \item На момент написания работы репозиторий со scala type debugger
  обновлялся в течение 5 лет.
  В статье~\cite{type_debugger1} говориться о том что eclipse, но нет.
\end{itemize}

Если же написать инструмент для анализа проверок типов основываясь исключительно
на коде Scala Plugin, то для использования такого инструмента не будет никаких
проблем.

\subsection{Show implicit parameters action}
\label{sec:showImplicit}

В качестве заключении рассмотрим как в рамках интегрированной среды
разработки помогать пользователю анализировать/моделировать работу выполняемую
компилятором.

В качестве примера мы будем использовать Show implicit parameters action.
Механизм implicit параметров.
Существуют определенные правила поиска соответвствующих параметров.

Эта штука показывает что да как.

Ссылка на сайт идеи.

\subsection{Постановка цели}

Можно привести три случая непостредственной пользы подобной штуки.

Понизить уровень вхождения.

Работа будет основана на работе плагина, а не компилятора.
Несмотря на, в некоторых нетривиальных случаях это может посочь.

Для людей которые должны работать с внутренним устройством плагина это может
помочь без необходимости непосредственной отладки.

\textbf{Цель:}
Сделать отладчик для процессов связанных с типами в рамках Scala Plugin.

\textbf{Задачи:}
\begin{itemize}
  \item Инструментировать Scala Plugin для сбора данных о процессе работы с типами.
  \item Дать интерпретиацию приближенную к спецификации.
  \item Минимизировать влияние инструментации во время выполнения на оставшуюся
  часть плагина.
\end{itemize}

Стоит сделать замечание, в разделе~\ref{sec:features} будет более подробно
рассказано почему в качестве способа сбора данных было выбрано именно
инструментирование исходного кода плагина.

Также не получится целиком давать интерпретацию данных основываясь на спецификации
потому что плагин порою ей не следует.
